import {
    'std'
}




module bin_heap {

MergeBt(Bt1, Bt2) :: (

        Bt1 <- bt(Value1, List1);
        Bt2 <- bt(Value2, List2);

        if Value1 >= Value2 then (
            R <- bt(Value2,[Bt1 | List2]);
            R
        ) else (
            R <- bt(Value1,[Bt2 | List1]);
            R
        )
)
.


AddBtAux(Bt , Heap : std:list, I : number) :: (
    Bt <- bt(Value, Children);
    Order <- std:Size(Children);
    HeapSize <- std:Size(Heap);

    if I = Order then (
        if HeapSize = 0 then (
            Result <- [Bt];
        ) else if Heap <- [CurrentBt | HeapTail] | CurrentBt = empty then (
            Result <- [Bt | HeapTail];
        ) else (
            NewHeapTail <- AddBtAux(MergeBt(CurrentBt,Bt),HeapTail,I+1);
            Result <- [ empty | NewHeapTail];
        );
    ) else if HeapSize = 0 then (
        std:PrintLn("Heap size does not match the binomial heap");
        std:Exit();
    ) else (
        Heap <- [ H | HeapTail];
        NewHeapTail <- AddBtAux(Bt,HeapTail, I + 1);
        Result <- [H | NewHeapTail];
    );

    Result

)
.

AddBt(Bt , Heap : std:list) :: (
    AddBtAux(Bt,Heap,0)
)
.


RemoveBt(Bt, Heap : std:list) :: (
    Bt <- bt(Value, Children);
    Order <- std:Size(Children);
    HeapSize <- std:Size(Heap);

    match Heap  {
        [] => [], 
        [Bt] => [],
        [Bt | HeapTail] => [empty | HeapTail],
        [H | HeapTail] => (
                NewHeapTail <- RemoveBt(Bt,HeapTail);
                [H | NewHeapTail]
        )
    }
)
.

PopMin(Heap : std:list)  :: (
    MinBt <- std:MinMember(Heap, (Bt1 ,Bt2 ) => (
        if Bt1 = empty then (
            Bt2
        ) else if Bt2 = empty then (
            Bt1
        ) else (
            Bt1 <- bt(Value1, _);
            Bt2 <- bt(Value2, _);
            if Value1 =< Value2 then (
                Bt1 
            ) else (
                Bt2
            )
        )
    ));

    MinBt <- bt(Value,List);
    ResultHeap <- AddList(List,RemoveBt(MinBt,Heap));

    (MinBt,ResultHeap)
)
.

Add(Num : number,Heap : std:list) :: (
    AddBt(bt(Num, []),Heap)
)
.

AddList(List , Heap) :: (
    ListSize <- std:Size(List);

    match std:Size(List) {
        0 => Heap,
        else => (
             List <- [Bt | ListTail];
             AddBt(Bt,AddList(ListTail,Heap))
        )
    }
)
.


ListToHeap(List : std:list) :: (
    match std:Size(List)  {
        0 => [],
        else => (
                List <- [L | Ls];
                Add(L,ListToHeap(Ls))
        )
    }
)
.

HeapToList(Heap : std:list) :: (
    HeapSize <- std:Size(Heap);
    if  HeapSize = 0 then (
        []
    ) else (
        (MinBt, NewHeap) <- PopMin(Heap);
        MinBt <- bt(Value , _);
        Tail <- HeapToList(NewHeap);
        [Value | Tail]
    )
)
.

pub HeapSort(List : std:list) :: (
    HeapToList(ListToHeap(List))
)
.

}

bt(_, []).

bt(Value , [bt(ChildValue,ChildList) | RootListTail] ) :- 
    length(RootListTail, K), 
    length(ChildList, K),
    Value =< ChildValue,
    bt(Value,RootListTail)
    .
